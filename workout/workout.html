<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='' xml:lang=''>

<head>
    <link rel="stylesheet" href="./pico.min.css">
    <style>
        .footer {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            text-align: center;
            margin: 0px;
        }
    </style>
</head>

<body>

    <article>
        <div id="container">
            <h2>Day 1</h2>
            <table>
                <thead>
                    <tr>
                        <th scope="col">
                            <h6>Exercise</h6>
                        </th>
                        <th scope="col">
                            <h6>Set 1</h6>
                        </th>
                        <th scope="col">
                            <h6>Set 2</h6>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <th scope="row">Bench Press</th>
                        <td>
                            <input type="text" id="firstname" name="firstname" placeholder="4x12" required>
                            <br />
                            <input type="text" id="firstname" name="firstname" placeholder="4x12" required>
                        </td>
                        <td>
                            <input type="text" id="firstname" name="firstname" placeholder="4x12" required>
                            <br />
                            <input type="text" id="firstname" name="firstname" placeholder="4x12" required>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <footer class="footer">
            <button id="start" onclick="startTimer()" disabled>Start Timer</button>
            <div id="timer" style="margin-bottom:20px;">0:00s</div>
            <div class="grid">
                <button id="reset" onclick="resetTimer()" disabled>Reset Timer</button>
                <button id="stop" onclick="endTimer(event)" disabled>Stop Timer</button>
            </div>
        </footer>
    </article>

    <script>
        // Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
        // This work is free. You can redistribute it and/or modify it
        // under the terms of the WTFPL, Version 2
        // For more information see LICENSE.txt or http://www.wtfpl.net/
        //
        // For more information, the home page:
        // http://pieroxy.net/blog/pages/lz-string/testing.html
        //
        // LZ-based compression algorithm, version 1.4.4
        var LZString = (function () {

            // private property
            var f = String.fromCharCode;
            var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
            var baseReverseDic = {};

            function getBaseValue(alphabet, character) {
                if (!baseReverseDic[alphabet]) {
                    baseReverseDic[alphabet] = {};
                    for (var i = 0; i < alphabet.length; i++) {
                        baseReverseDic[alphabet][alphabet.charAt(i)] = i;
                    }
                }
                return baseReverseDic[alphabet][character];
            }

            var LZString = {
                compressToBase64: function (input) {
                    if (input == null) return "";
                    var res = LZString._compress(input, 6, function (a) { return keyStrBase64.charAt(a); });
                    switch (res.length % 4) { // To produce valid Base64
                        default: // When could this happen ?
                        case 0: return res;
                        case 1: return res + "===";
                        case 2: return res + "==";
                        case 3: return res + "=";
                    }
                },

                decompressFromBase64: function (input) {
                    if (input == null) return "";
                    if (input == "") return null;
                    return LZString._decompress(input.length, 32, function (index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
                },

                compressToUTF16: function (input) {
                    if (input == null) return "";
                    return LZString._compress(input, 15, function (a) { return f(a + 32); }) + " ";
                },

                decompressFromUTF16: function (compressed) {
                    if (compressed == null) return "";
                    if (compressed == "") return null;
                    return LZString._decompress(compressed.length, 16384, function (index) { return compressed.charCodeAt(index) - 32; });
                },

                //compress into uint8array (UCS-2 big endian format)
                compressToUint8Array: function (uncompressed) {
                    var compressed = LZString.compress(uncompressed);
                    var buf = new Uint8Array(compressed.length * 2); // 2 bytes per character

                    for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
                        var current_value = compressed.charCodeAt(i);
                        buf[i * 2] = current_value >>> 8;
                        buf[i * 2 + 1] = current_value % 256;
                    }
                    return buf;
                },

                //decompress from uint8array (UCS-2 big endian format)
                decompressFromUint8Array: function (compressed) {
                    if (compressed === null || compressed === undefined) {
                        return LZString.decompress(compressed);
                    } else {
                        var buf = new Array(compressed.length / 2); // 2 bytes per character
                        for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
                            buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
                        }

                        var result = [];
                        buf.forEach(function (c) {
                            result.push(f(c));
                        });
                        return LZString.decompress(result.join(''));

                    }

                },


                //compress into a string that is already URI encoded
                compressToEncodedURIComponent: function (input) {
                    if (input == null) return "";
                    return LZString._compress(input, 6, function (a) { return keyStrUriSafe.charAt(a); });
                },

                //decompress from an output of compressToEncodedURIComponent
                decompressFromEncodedURIComponent: function (input) {
                    if (input == null) return "";
                    if (input == "") return null;
                    input = input.replace(/ /g, "+");
                    return LZString._decompress(input.length, 32, function (index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
                },

                compress: function (uncompressed) {
                    return LZString._compress(uncompressed, 16, function (a) { return f(a); });
                },
                _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
                    if (uncompressed == null) return "";
                    var i, value,
                        context_dictionary = {},
                        context_dictionaryToCreate = {},
                        context_c = "",
                        context_wc = "",
                        context_w = "",
                        context_enlargeIn = 2, // Compensate for the first entry which should not count
                        context_dictSize = 3,
                        context_numBits = 2,
                        context_data = [],
                        context_data_val = 0,
                        context_data_position = 0,
                        ii;

                    for (ii = 0; ii < uncompressed.length; ii += 1) {
                        context_c = uncompressed.charAt(ii);
                        if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                            context_dictionary[context_c] = context_dictSize++;
                            context_dictionaryToCreate[context_c] = true;
                        }

                        context_wc = context_w + context_c;
                        if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                            context_w = context_wc;
                        } else {
                            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                                if (context_w.charCodeAt(0) < 256) {
                                    for (i = 0; i < context_numBits; i++) {
                                        context_data_val = (context_data_val << 1);
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                    }
                                    value = context_w.charCodeAt(0);
                                    for (i = 0; i < 8; i++) {
                                        context_data_val = (context_data_val << 1) | (value & 1);
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                                } else {
                                    value = 1;
                                    for (i = 0; i < context_numBits; i++) {
                                        context_data_val = (context_data_val << 1) | value;
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = 0;
                                    }
                                    value = context_w.charCodeAt(0);
                                    for (i = 0; i < 16; i++) {
                                        context_data_val = (context_data_val << 1) | (value & 1);
                                        if (context_data_position == bitsPerChar - 1) {
                                            context_data_position = 0;
                                            context_data.push(getCharFromInt(context_data_val));
                                            context_data_val = 0;
                                        } else {
                                            context_data_position++;
                                        }
                                        value = value >> 1;
                                    }
                                }
                                context_enlargeIn--;
                                if (context_enlargeIn == 0) {
                                    context_enlargeIn = Math.pow(2, context_numBits);
                                    context_numBits++;
                                }
                                delete context_dictionaryToCreate[context_w];
                            } else {
                                value = context_dictionary[context_w];
                                for (i = 0; i < context_numBits; i++) {
                                    context_data_val = (context_data_val << 1) | (value & 1);
                                    if (context_data_position == bitsPerChar - 1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                    } else {
                                        context_data_position++;
                                    }
                                    value = value >> 1;
                                }


                            }
                            context_enlargeIn--;
                            if (context_enlargeIn == 0) {
                                context_enlargeIn = Math.pow(2, context_numBits);
                                context_numBits++;
                            }
                            // Add wc to the dictionary.
                            context_dictionary[context_wc] = context_dictSize++;
                            context_w = String(context_c);
                        }
                    }

                    // Output the code for w.
                    if (context_w !== "") {
                        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                            if (context_w.charCodeAt(0) < 256) {
                                for (i = 0; i < context_numBits; i++) {
                                    context_data_val = (context_data_val << 1);
                                    if (context_data_position == bitsPerChar - 1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                    } else {
                                        context_data_position++;
                                    }
                                }
                                value = context_w.charCodeAt(0);
                                for (i = 0; i < 8; i++) {
                                    context_data_val = (context_data_val << 1) | (value & 1);
                                    if (context_data_position == bitsPerChar - 1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                    } else {
                                        context_data_position++;
                                    }
                                    value = value >> 1;
                                }
                            } else {
                                value = 1;
                                for (i = 0; i < context_numBits; i++) {
                                    context_data_val = (context_data_val << 1) | value;
                                    if (context_data_position == bitsPerChar - 1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                    } else {
                                        context_data_position++;
                                    }
                                    value = 0;
                                }
                                value = context_w.charCodeAt(0);
                                for (i = 0; i < 16; i++) {
                                    context_data_val = (context_data_val << 1) | (value & 1);
                                    if (context_data_position == bitsPerChar - 1) {
                                        context_data_position = 0;
                                        context_data.push(getCharFromInt(context_data_val));
                                        context_data_val = 0;
                                    } else {
                                        context_data_position++;
                                    }
                                    value = value >> 1;
                                }
                            }
                            context_enlargeIn--;
                            if (context_enlargeIn == 0) {
                                context_enlargeIn = Math.pow(2, context_numBits);
                                context_numBits++;
                            }
                            delete context_dictionaryToCreate[context_w];
                        } else {
                            value = context_dictionary[context_w];
                            for (i = 0; i < context_numBits; i++) {
                                context_data_val = (context_data_val << 1) | (value & 1);
                                if (context_data_position == bitsPerChar - 1) {
                                    context_data_position = 0;
                                    context_data.push(getCharFromInt(context_data_val));
                                    context_data_val = 0;
                                } else {
                                    context_data_position++;
                                }
                                value = value >> 1;
                            }


                        }
                        context_enlargeIn--;
                        if (context_enlargeIn == 0) {
                            context_enlargeIn = Math.pow(2, context_numBits);
                            context_numBits++;
                        }
                    }

                    // Mark the end of the stream
                    value = 2;
                    for (i = 0; i < context_numBits; i++) {
                        context_data_val = (context_data_val << 1) | (value & 1);
                        if (context_data_position == bitsPerChar - 1) {
                            context_data_position = 0;
                            context_data.push(getCharFromInt(context_data_val));
                            context_data_val = 0;
                        } else {
                            context_data_position++;
                        }
                        value = value >> 1;
                    }

                    // Flush the last char
                    while (true) {
                        context_data_val = (context_data_val << 1);
                        if (context_data_position == bitsPerChar - 1) {
                            context_data.push(getCharFromInt(context_data_val));
                            break;
                        }
                        else context_data_position++;
                    }
                    return context_data.join('');
                },

                decompress: function (compressed) {
                    if (compressed == null) return "";
                    if (compressed == "") return null;
                    return LZString._decompress(compressed.length, 32768, function (index) { return compressed.charCodeAt(index); });
                },

                _decompress: function (length, resetValue, getNextValue) {
                    var dictionary = [],
                        next,
                        enlargeIn = 4,
                        dictSize = 4,
                        numBits = 3,
                        entry = "",
                        result = [],
                        i,
                        w,
                        bits, resb, maxpower, power,
                        c,
                        data = { val: getNextValue(0), position: resetValue, index: 1 };

                    for (i = 0; i < 3; i += 1) {
                        dictionary[i] = i;
                    }

                    bits = 0;
                    maxpower = Math.pow(2, 2);
                    power = 1;
                    while (power != maxpower) {
                        resb = data.val & data.position;
                        data.position >>= 1;
                        if (data.position == 0) {
                            data.position = resetValue;
                            data.val = getNextValue(data.index++);
                        }
                        bits |= (resb > 0 ? 1 : 0) * power;
                        power <<= 1;
                    }

                    switch (next = bits) {
                        case 0:
                            bits = 0;
                            maxpower = Math.pow(2, 8);
                            power = 1;
                            while (power != maxpower) {
                                resb = data.val & data.position;
                                data.position >>= 1;
                                if (data.position == 0) {
                                    data.position = resetValue;
                                    data.val = getNextValue(data.index++);
                                }
                                bits |= (resb > 0 ? 1 : 0) * power;
                                power <<= 1;
                            }
                            c = f(bits);
                            break;
                        case 1:
                            bits = 0;
                            maxpower = Math.pow(2, 16);
                            power = 1;
                            while (power != maxpower) {
                                resb = data.val & data.position;
                                data.position >>= 1;
                                if (data.position == 0) {
                                    data.position = resetValue;
                                    data.val = getNextValue(data.index++);
                                }
                                bits |= (resb > 0 ? 1 : 0) * power;
                                power <<= 1;
                            }
                            c = f(bits);
                            break;
                        case 2:
                            return "";
                    }
                    dictionary[3] = c;
                    w = c;
                    result.push(c);
                    while (true) {
                        if (data.index > length) {
                            return "";
                        }

                        bits = 0;
                        maxpower = Math.pow(2, numBits);
                        power = 1;
                        while (power != maxpower) {
                            resb = data.val & data.position;
                            data.position >>= 1;
                            if (data.position == 0) {
                                data.position = resetValue;
                                data.val = getNextValue(data.index++);
                            }
                            bits |= (resb > 0 ? 1 : 0) * power;
                            power <<= 1;
                        }

                        switch (c = bits) {
                            case 0:
                                bits = 0;
                                maxpower = Math.pow(2, 8);
                                power = 1;
                                while (power != maxpower) {
                                    resb = data.val & data.position;
                                    data.position >>= 1;
                                    if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                    }
                                    bits |= (resb > 0 ? 1 : 0) * power;
                                    power <<= 1;
                                }

                                dictionary[dictSize++] = f(bits);
                                c = dictSize - 1;
                                enlargeIn--;
                                break;
                            case 1:
                                bits = 0;
                                maxpower = Math.pow(2, 16);
                                power = 1;
                                while (power != maxpower) {
                                    resb = data.val & data.position;
                                    data.position >>= 1;
                                    if (data.position == 0) {
                                        data.position = resetValue;
                                        data.val = getNextValue(data.index++);
                                    }
                                    bits |= (resb > 0 ? 1 : 0) * power;
                                    power <<= 1;
                                }
                                dictionary[dictSize++] = f(bits);
                                c = dictSize - 1;
                                enlargeIn--;
                                break;
                            case 2:
                                return result.join('');
                        }

                        if (enlargeIn == 0) {
                            enlargeIn = Math.pow(2, numBits);
                            numBits++;
                        }

                        if (dictionary[c]) {
                            entry = dictionary[c];
                        } else {
                            if (c === dictSize) {
                                entry = w + w.charAt(0);
                            } else {
                                return null;
                            }
                        }
                        result.push(entry);

                        // Add w+entry[0] to the dictionary.
                        dictionary[dictSize++] = w + entry.charAt(0);
                        enlargeIn--;

                        w = entry;

                        if (enlargeIn == 0) {
                            enlargeIn = Math.pow(2, numBits);
                            numBits++;
                        }

                    }
                }
            };
            return LZString;
        })();

        if (typeof define === 'function' && define.amd) {
            define(function () { return LZString; });
        } else if (typeof module !== 'undefined' && module != null) {
            module.exports = LZString
        } else if (typeof angular !== 'undefined' && angular != null) {
            angular.module('LZString', [])
                .factory('LZString', function () {
                    return LZString;
                });
        }
    </script>
    <script>
        var data = {
            day1: [
                "bench press:80,12,80,10,80,8,80,8",
                "incline bench press:60,10,60,9,60,8,60,8",
                "cable hi to low flys:80,12,80,12,70,12,70,12",
                "prison arms:25,36,20,36",
                "tricep pushdowns:70,12,60,12"
            ],
            day2: [
                "single arm cable lat pulldown:80,12,80,10,80,8,80,8",
                "bb row:60,10,60,9,60,8,60,8",
                "cable row:80,12,80,12,70,12,70,12",
                "cable rear delt fly:25,36,20,36",
                "dumbbell curl:70,12,60,12",
                "incline dumbbell curl:70,12,60,12",
                "crossbody hammer curls:70,12,60,12"
            ],
            day3: [
                "squat:80,12,80,10,80,8,80,8",
                "db split squat:60,10,609,60,8,60,8",
                "bb calf raises:80,12,80,12,70,12,70,12",
                "db shoulder press:25,36,20,36",
                "lateral raise + front raise:70,12,60,12"
            ],
            day4: [
                "incline walking:1,30"
            ]
        };

        var urlData = new URLSearchParams(window.location.search).get("data");
        if (urlData) {
            var workouts = JSON.parse(LZString.decompressFromEncodedURIComponent(urlData));
            var parsedWorkouts = {};
            console.log(workouts);

            const container = document.getElementById("container");
            container.innerHTML = "";
            for (let day in workouts) {
                console.log(day);
                console.log(workouts[day])
                parsedWorkouts[day] = [];
                let tableHTML = `<details>
  <summary><h2>${day}</h2></summary>
  <button id="start${day}" onclick="startWorkout('${day}')">Start Workout</button>
            <table>
                <thead>
                    <tr>
                        <th scope="col"><h6>Exercise</h6></th>
                        <th scope="col"><h6>Set 1</h6></th>
                        <th scope="col"><h6>Set 2</h6></th>
                        <th scope="col"><h6>Set 3</h6></th>
                        <th scope="col"><h6>Set 4</h6></th>
                    </tr>
                </thead>
                <tbody>
                    `;
                for (let ex in workouts[day]) {
                    const e = workouts[day][ex].split(":");
                    const name = e[0];
                    const sets = e[1].split(",");
                    parsedWorkouts[day].push(sets.length / 2);
                    console.log(name + " " + sets);
                    tableHTML += `<tr><th scope="row"><input type="text" id="${name}" value="${name}"></th>`;
                    for (let i = 0; i < sets.length; i += 2) {
                        tableHTML += `
                        <td>
                        <input type="number" id="${day}${ex}${i / 2}weight" placeholder="${sets[i]}">
                        <br />
                        <input type="number" id="${day}${ex}${i / 2}reps" placeholder="${sets[i + 1]}">
                        </td >
                            `
                    }
                }
                tableHTML += `</tr ></tbody ></table ></details> <br />`
                container.innerHTML += tableHTML;
            }
        }

        let timer = null;
        let val = 0;
        let currentDay = null;
        let currentExercise = 0;
        let currentSet = 0;
        const startTimer = () => {
            console.log("starting timer");
            document.getElementById("start").disabled = true;
            document.getElementById("stop").disabled = false;
            document.getElementById("reset").disabled = false;
            if (timer !== null) return;
            val = 0;
            timer = setInterval(function () {
                val += 1;
                document.getElementById("timer").innerHTML = `${Math.floor(val / 60)}:${(val % 60).toLocaleString('en-US', {
                    minimumIntegerDigits: 2,
                    useGrouping: false
                })}s`;
            }, 1000);
            document.getElementById("reps").value = document.getElementById(`${currentDay}${currentExercise}${currentSet}reps`).placeholder;
            document.getElementById("weight").value = document.getElementById(`${currentDay}${currentExercise}${currentSet}weight`).placeholder;
            toggleModal("set-modal");
        }

        const resetTimer = () => {
            val = 0;
        }

        const logSet = () => {
            toggleModal("set-modal");
            document.getElementById(`${currentDay}${currentExercise}${currentSet}reps`).value = document.getElementById("reps").value;
            document.getElementById(`${currentDay}${currentExercise}${currentSet}weight`).value = document.getElementById("weight").value;
            document.getElementById(`${currentDay}${currentExercise}${currentSet}reps`).setAttribute('aria-invalid', "false");
            document.getElementById(`${currentDay}${currentExercise}${currentSet}weight`).setAttribute('aria-invalid', "false");
            currentSet++;
            if (currentSet > parsedWorkouts[currentDay][currentExercise]) {
                currentExercise++;
                currentSet = 0;
            }
        }

        const endTimer = (event) => {
            document.getElementById("start").disabled = false;
            document.getElementById("stop").disabled = true;
            document.getElementById("reset").disabled = true;
            clearInterval(timer);
            timer = null;
            console.log("ending timer");
        }

        const startWorkout = (day) => {
            console.log(`starting: ${day}`);
            document.getElementById(`start${day}`).disabled = true;
            document.getElementById("start").disabled = false;
            currentDay = day;
            currentExercise = 0;
            currentSet = 0;
            console.log(parsedWorkouts[currentDay][currentExercise]);
        }
    </script>

    <!-- Modal -->
    <dialog id="set-modal">
        <article>
            <h3>Set Finished!</h3>
            <label for="weight">
                Weight
                <input type="number" id="weight" name="weight" value="First name" required>
            </label>
            <label for="reps">
                Rep Count
                <input type="number" id="reps" name="reps" value="First name" required>
            </label>
            <footer>
                <a href="#confirm" role="button" data-target="modal-example" onClick="logSet()">
                    Done
                </a>
            </footer>
        </article>
    </dialog>

    <script>
        // Config
        const isOpenClass = 'modal-is-open';
        const openingClass = 'modal-is-opening';
        const closingClass = 'modal-is-closing';
        const animationDuration = 400; // ms
        let visibleModal = null;


        // Toggle modal
        const toggleModal = id => {
            const modal = document.getElementById(id);
            (typeof (modal) != 'undefined' && modal != null)
                && isModalOpen(modal) ? closeModal(modal) : openModal(modal)
        }

        // Is modal open
        const isModalOpen = modal => {
            return modal.hasAttribute('open') && modal.getAttribute('open') != 'false' ? true : false;
        }

        // Open modal
        const openModal = modal => {
            if (isScrollbarVisible()) {
                document.documentElement.style.setProperty('--scrollbar-width', `${getScrollbarWidth()}px`);
            }
            document.documentElement.classList.add(isOpenClass, openingClass);
            setTimeout(() => {
                visibleModal = modal;
                document.documentElement.classList.remove(openingClass);
            }, animationDuration);
            modal.setAttribute('open', true);
        }

        // Close modal
        const closeModal = modal => {
            visibleModal = null;
            document.documentElement.classList.add(closingClass);
            setTimeout(() => {
                document.documentElement.classList.remove(closingClass, isOpenClass);
                document.documentElement.style.removeProperty('--scrollbar-width');
                modal.removeAttribute('open');
            }, animationDuration);
        }

        // Close with a click outside
        document.addEventListener('click', event => {
            if (visibleModal != null) {
                const modalContent = visibleModal.querySelector('article');
                const isClickInside = modalContent.contains(event.target);
                !isClickInside && closeModal(visibleModal);
            }
        });

        // Close with Esc key
        document.addEventListener('keydown', event => {
            if (event.key === 'Escape' && visibleModal != null) {
                closeModal(visibleModal);
            }
        });

        // Get scrollbar width
        const getScrollbarWidth = () => {

            // Creating invisible container
            const outer = document.createElement('div');
            outer.style.visibility = 'hidden';
            outer.style.overflow = 'scroll'; // forcing scrollbar to appear
            outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
            document.body.appendChild(outer);

            // Creating inner element and placing it in the container
            const inner = document.createElement('div');
            outer.appendChild(inner);

            // Calculating difference between container's full width and the child width
            const scrollbarWidth = (outer.offsetWidth - inner.offsetWidth);

            // Removing temporary elements from the DOM
            outer.parentNode.removeChild(outer);

            return scrollbarWidth;
        }

        // Is scrollbar visible
        const isScrollbarVisible = () => {
            return document.body.scrollHeight > screen.height;
        }
    </script>
</body>

</html>